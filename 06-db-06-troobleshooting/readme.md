# Домашнее задание к занятию "6.6. Troubleshooting"
## Задание 1 `MongoDB`
Опеределить текущую операцию можно при помощи `db.currentOp()`
```SQL
db.currentOp().inprog.forEach(function (op) {
  if (op.secs_running > 100) printjson(op);
});
```
Завершить запрос можно с помощью ключа `db.killOp()`
```SQL
db.killOp(op.opid);
```
Для оптимизация таких запросов можно применить следующие патерны
 - постороить/перестроить соответствующий индекс
 - Добавлять к запросам метод `maxTimeMS` для автоматического вызова `db.killOp()`
 ## Задача 2 `Redis`
Проблема может быть вызвана истечением срока действия ключей.  
Алгоритм `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` является адаптивным и зациклится, если обнаружит, что более 25% ключей уже просрочены в наборе выбранных ключей.
В основном это означает, что если в базе данных есть много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия , Redis может заблокировать, чтобы получить процент ключей, срок действия которых истек ниже, чем 25%.

  ## Задание 3 `MySQL`
  данная проблема вызвана большим временем обработки запроса, после чего соединение пррывается по таймауту. Решение:
  - Увеличить значение параметров : connect_timeout, interactive_timeout, wait_timeout
  - Оптимизация запросов
  - Шадрирование больших таблиц
  - Индексация
  - Добавление ресурсов хосту
  ## Задание 4 `PostgreSQL`
  Проблема вызвана исчерпанием оперативной памяти на сервере с `PostgreSQL`
  Необзходимо выставить лимит на использование ОЗУ. Для расчета лимита можно воспользоваться формулой `shared_buffers + (temp_buffers + work_mem) * max_connections)`. При этом добавить на сервер памяти примерно на 30% больше расчитанного.
 Тюнинг сервера `PostgreSQL`
```bash
sysctl -w vm.overcommit_memory=2
echo -1000 > /proc/self/oom_score_adj
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
```
